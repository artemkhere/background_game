{"ast":null,"code":"import socketIOClient from 'socket.io-client';\nimport { SOCKET_TRIGGER_CONNECT, SOCKET_TRIGGER_DISCONNECT, SOCKET_EMIT } from '../actions/actionTypes';\nimport { setSocketLoading, handleSocketConnect, setSocketError } from '../actions/socketActions';\nimport { updateGameSessionState } from '../actions/gameSessionActions';\n\nconst createSocketMiddleware = url => {\n  let socket;\n  return storeAPI => next => action => {\n    const dispatch = storeAPI.dispatch;\n\n    switch (action.type) {\n      case SOCKET_TRIGGER_CONNECT:\n        setSocketLoading(dispatch, true);\n        socket = socketIOClient(url);\n        socket.on('connect', data => {\n          const {\n            user\n          } = storeAPI.getState();\n          handleSocketConnect(dispatch, user);\n        });\n        socket.on('connect_error', error => {\n          setSocketError(dispatch, error);\n        });\n        socket.on('error', error => {\n          setSocketError(dispatch, error);\n        });\n        socket.on('gameSessionError', error => {\n          setSocketError(dispatch, error);\n        });\n        socket.on('connect_timeout', timeout => {\n          setSocketError(dispatch, timeout);\n        });\n        socket.on('disconnect', reason => {\n          // reason is a String\n          // ‘io server disconnect’, ‘io client disconnect’, or ‘ping timeout’\n          setSocketError(dispatch, {\n            message: reason\n          });\n        });\n        socket.on('updateGameSession', data => {\n          updateGameSessionState(dispatch, data);\n        });\n        break;\n\n      case SOCKET_TRIGGER_DISCONNECT:\n        if (socket) {\n          socket.disconnect();\n        }\n\n        return;\n\n      case SOCKET_EMIT:\n        const {\n          eventName\n        } = action.payload;\n        const data = action.payload.data || {};\n\n        if (socket && socket.connected) {\n          socket.emit(eventName, data);\n        } else {\n          setSocketError(dispatch, {\n            message: 'Socket is not connected'\n          });\n        }\n\n        return;\n\n      default:\n        break;\n    }\n\n    return next(action);\n  };\n};\n\nexport default createSocketMiddleware;","map":{"version":3,"sources":["/Users/artemk/background_game/frontend/src/store/socketMiddleware.js"],"names":["socketIOClient","SOCKET_TRIGGER_CONNECT","SOCKET_TRIGGER_DISCONNECT","SOCKET_EMIT","setSocketLoading","handleSocketConnect","setSocketError","updateGameSessionState","createSocketMiddleware","url","socket","storeAPI","next","action","dispatch","type","on","data","user","getState","error","timeout","reason","message","disconnect","eventName","payload","connected","emit"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SACEC,sBADF,EAC0BC,yBAD1B,EACqDC,WADrD,QAEO,wBAFP;AAGA,SACEC,gBADF,EACoBC,mBADpB,EACyCC,cADzC,QAEO,0BAFP;AAGA,SAASC,sBAAT,QAAuC,+BAAvC;;AAEA,MAAMC,sBAAsB,GAAIC,GAAD,IAAS;AACtC,MAAIC,MAAJ;AAEA,SAAOC,QAAQ,IAAIC,IAAI,IAAIC,MAAM,IAAI;AACnC,UAAMC,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;;AAEA,YAAOD,MAAM,CAACE,IAAd;AACE,WAAKd,sBAAL;AACEG,QAAAA,gBAAgB,CAACU,QAAD,EAAW,IAAX,CAAhB;AAEAJ,QAAAA,MAAM,GAAGV,cAAc,CAACS,GAAD,CAAvB;AAEAC,QAAAA,MAAM,CAACM,EAAP,CAAU,SAAV,EAAsBC,IAAD,IAAU;AAC7B,gBAAM;AAAEC,YAAAA;AAAF,cAAWP,QAAQ,CAACQ,QAAT,EAAjB;AACAd,UAAAA,mBAAmB,CAACS,QAAD,EAAWI,IAAX,CAAnB;AACD,SAHD;AAKAR,QAAAA,MAAM,CAACM,EAAP,CAAU,eAAV,EAA4BI,KAAD,IAAW;AACpCd,UAAAA,cAAc,CAACQ,QAAD,EAAWM,KAAX,CAAd;AACD,SAFD;AAIAV,QAAAA,MAAM,CAACM,EAAP,CAAU,OAAV,EAAoBI,KAAD,IAAW;AAC5Bd,UAAAA,cAAc,CAACQ,QAAD,EAAWM,KAAX,CAAd;AACD,SAFD;AAIAV,QAAAA,MAAM,CAACM,EAAP,CAAU,kBAAV,EAA+BI,KAAD,IAAW;AACvCd,UAAAA,cAAc,CAACQ,QAAD,EAAWM,KAAX,CAAd;AACD,SAFD;AAIAV,QAAAA,MAAM,CAACM,EAAP,CAAU,iBAAV,EAA8BK,OAAD,IAAa;AACxCf,UAAAA,cAAc,CAACQ,QAAD,EAAWO,OAAX,CAAd;AACD,SAFD;AAIAX,QAAAA,MAAM,CAACM,EAAP,CAAU,YAAV,EAAyBM,MAAD,IAAY;AAClC;AACA;AACAhB,UAAAA,cAAc,CAACQ,QAAD,EAAW;AAAES,YAAAA,OAAO,EAAED;AAAX,WAAX,CAAd;AACD,SAJD;AAMAZ,QAAAA,MAAM,CAACM,EAAP,CAAU,mBAAV,EAAgCC,IAAD,IAAU;AACvCV,UAAAA,sBAAsB,CAACO,QAAD,EAAWG,IAAX,CAAtB;AACD,SAFD;AAGA;;AACF,WAAKf,yBAAL;AACE,YAAIQ,MAAJ,EAAY;AAAEA,UAAAA,MAAM,CAACc,UAAP;AAAsB;;AACpC;;AACF,WAAKrB,WAAL;AACE,cAAM;AAAEsB,UAAAA;AAAF,YAAgBZ,MAAM,CAACa,OAA7B;AACA,cAAMT,IAAI,GAAGJ,MAAM,CAACa,OAAP,CAAeT,IAAf,IAAuB,EAApC;;AAEA,YAAIP,MAAM,IAAIA,MAAM,CAACiB,SAArB,EAAgC;AAC9BjB,UAAAA,MAAM,CAACkB,IAAP,CAAYH,SAAZ,EAAuBR,IAAvB;AACD,SAFD,MAEO;AACLX,UAAAA,cAAc,CAACQ,QAAD,EAAW;AAAES,YAAAA,OAAO,EAAE;AAAX,WAAX,CAAd;AACD;;AACD;;AACF;AACE;AAnDJ;;AAsDA,WAAOX,IAAI,CAACC,MAAD,CAAX;AACD,GA1DD;AA2DD,CA9DD;;AAgEA,eAAeL,sBAAf","sourcesContent":["import socketIOClient from 'socket.io-client';\nimport {\n  SOCKET_TRIGGER_CONNECT, SOCKET_TRIGGER_DISCONNECT, SOCKET_EMIT\n} from '../actions/actionTypes';\nimport {\n  setSocketLoading, handleSocketConnect, setSocketError\n} from '../actions/socketActions';\nimport { updateGameSessionState } from '../actions/gameSessionActions';\n\nconst createSocketMiddleware = (url) => {\n  let socket;\n\n  return storeAPI => next => action => {\n    const dispatch = storeAPI.dispatch;\n\n    switch(action.type) {\n      case SOCKET_TRIGGER_CONNECT:\n        setSocketLoading(dispatch, true);\n\n        socket = socketIOClient(url);\n\n        socket.on('connect', (data) => {\n          const { user } = storeAPI.getState();\n          handleSocketConnect(dispatch, user);\n        });\n\n        socket.on('connect_error', (error) => {\n          setSocketError(dispatch, error);\n        });\n\n        socket.on('error', (error) => {\n          setSocketError(dispatch, error);\n        });\n\n        socket.on('gameSessionError', (error) => {\n          setSocketError(dispatch, error);\n        });\n\n        socket.on('connect_timeout', (timeout) => {\n          setSocketError(dispatch, timeout);\n        });\n\n        socket.on('disconnect', (reason) => {\n          // reason is a String\n          // ‘io server disconnect’, ‘io client disconnect’, or ‘ping timeout’\n          setSocketError(dispatch, { message: reason });\n        });\n\n        socket.on('updateGameSession', (data) => {\n          updateGameSessionState(dispatch, data);\n        });\n        break;\n      case SOCKET_TRIGGER_DISCONNECT:\n        if (socket) { socket.disconnect(); }\n        return;\n      case SOCKET_EMIT:\n        const { eventName } = action.payload;\n        const data = action.payload.data || {};\n\n        if (socket && socket.connected) {\n          socket.emit(eventName, data);\n        } else {\n          setSocketError(dispatch, { message: 'Socket is not connected' });\n        }\n        return;\n      default:\n        break;\n    }\n\n    return next(action);\n  }\n}\n\nexport default createSocketMiddleware;\n"]},"metadata":{},"sourceType":"module"}