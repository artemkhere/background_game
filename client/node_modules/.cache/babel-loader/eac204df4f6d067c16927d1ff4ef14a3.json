{"ast":null,"code":"import socketIOClient from 'socket.io-client';\nimport { SOCKET_TRIGGER_CONNECT, SOCKET_TRIGGER_DISCONNECT, SOCKET_EMIT } from '../actions/actionTypes';\nimport { setSocketLoading, handleSocketConnect, setSocketError } from '../actions/socketActions';\n\nconst createSocketMiddleware = url => {\n  let socket;\n  return storeAPI => next => action => {\n    const dispatch = storeAPI.dispatch;\n\n    switch (action.type) {\n      case SOCKET_TRIGGER_CONNECT:\n        setSocketLoading(dispatch, true);\n        socket = socketIOClient(url);\n        socket.on('connect', data => {\n          handleSocketConnect(dispatch, data);\n        });\n        socket.on('connect_error', error => {\n          setSocketError(dispatch, error);\n        });\n        socket.on('error', error => {\n          setSocketError(dispatch, error);\n        });\n        socket.on('connect_timeout', timeout => {\n          setSocketError(dispatch, timeout);\n        });\n        socket.on('disconnect', reason => {\n          // reason is a String\n          // ‘io server disconnect’, ‘io client disconnect’, or ‘ping timeout’\n          setSocketError(dispatch, {\n            message: reason\n          });\n        });\n        socket.on('updateGameSession', data => {\n          setGameSessionState(dispatch, data);\n        });\n        break;\n\n      case SOCKET_TRIGGER_DISCONNECT:\n        if (socket) {\n          socket.disconnect();\n        }\n\n        return;\n\n      case SOCKET_EMIT:\n        const {\n          eventName\n        } = action.payload;\n        const data = action.payload.data || {};\n\n        if (socket && socket.connected) {\n          socket.emit(eventName, data);\n        } else {\n          setSocketError(dispatch, {\n            message: 'Socket is not connected'\n          });\n        }\n\n        return;\n\n      default:\n        break;\n    }\n\n    return next(action);\n  };\n};\n\nexport default createSocketMiddleware;","map":{"version":3,"sources":["/Users/artemk/background_game/frontend/src/store/socketMiddleware.js"],"names":["socketIOClient","SOCKET_TRIGGER_CONNECT","SOCKET_TRIGGER_DISCONNECT","SOCKET_EMIT","setSocketLoading","handleSocketConnect","setSocketError","createSocketMiddleware","url","socket","storeAPI","next","action","dispatch","type","on","data","error","timeout","reason","message","setGameSessionState","disconnect","eventName","payload","connected","emit"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SACEC,sBADF,EAC0BC,yBAD1B,EACqDC,WADrD,QAEO,wBAFP;AAGA,SACEC,gBADF,EACoBC,mBADpB,EACyCC,cADzC,QAEO,0BAFP;;AAIA,MAAMC,sBAAsB,GAAIC,GAAD,IAAS;AACtC,MAAIC,MAAJ;AAEA,SAAOC,QAAQ,IAAIC,IAAI,IAAIC,MAAM,IAAI;AACnC,UAAMC,QAAQ,GAAGH,QAAQ,CAACG,QAA1B;;AAEA,YAAOD,MAAM,CAACE,IAAd;AACE,WAAKb,sBAAL;AACEG,QAAAA,gBAAgB,CAACS,QAAD,EAAW,IAAX,CAAhB;AAEAJ,QAAAA,MAAM,GAAGT,cAAc,CAACQ,GAAD,CAAvB;AAEAC,QAAAA,MAAM,CAACM,EAAP,CAAU,SAAV,EAAsBC,IAAD,IAAU;AAC7BX,UAAAA,mBAAmB,CAACQ,QAAD,EAAWG,IAAX,CAAnB;AACD,SAFD;AAIAP,QAAAA,MAAM,CAACM,EAAP,CAAU,eAAV,EAA4BE,KAAD,IAAW;AACpCX,UAAAA,cAAc,CAACO,QAAD,EAAWI,KAAX,CAAd;AACD,SAFD;AAIAR,QAAAA,MAAM,CAACM,EAAP,CAAU,OAAV,EAAoBE,KAAD,IAAW;AAC5BX,UAAAA,cAAc,CAACO,QAAD,EAAWI,KAAX,CAAd;AACD,SAFD;AAIAR,QAAAA,MAAM,CAACM,EAAP,CAAU,iBAAV,EAA8BG,OAAD,IAAa;AACxCZ,UAAAA,cAAc,CAACO,QAAD,EAAWK,OAAX,CAAd;AACD,SAFD;AAIAT,QAAAA,MAAM,CAACM,EAAP,CAAU,YAAV,EAAyBI,MAAD,IAAY;AAClC;AACA;AACAb,UAAAA,cAAc,CAACO,QAAD,EAAW;AAAEO,YAAAA,OAAO,EAAED;AAAX,WAAX,CAAd;AACD,SAJD;AAMAV,QAAAA,MAAM,CAACM,EAAP,CAAU,mBAAV,EAAgCC,IAAD,IAAU;AACvCK,UAAAA,mBAAmB,CAACR,QAAD,EAAWG,IAAX,CAAnB;AACD,SAFD;AAGA;;AACF,WAAKd,yBAAL;AACE,YAAIO,MAAJ,EAAY;AAAEA,UAAAA,MAAM,CAACa,UAAP;AAAsB;;AACpC;;AACF,WAAKnB,WAAL;AACE,cAAM;AAAEoB,UAAAA;AAAF,YAAgBX,MAAM,CAACY,OAA7B;AACA,cAAMR,IAAI,GAAGJ,MAAM,CAACY,OAAP,CAAeR,IAAf,IAAuB,EAApC;;AAEA,YAAIP,MAAM,IAAIA,MAAM,CAACgB,SAArB,EAAgC;AAC9BhB,UAAAA,MAAM,CAACiB,IAAP,CAAYH,SAAZ,EAAuBP,IAAvB;AACD,SAFD,MAEO;AACLV,UAAAA,cAAc,CAACO,QAAD,EAAW;AAAEO,YAAAA,OAAO,EAAE;AAAX,WAAX,CAAd;AACD;;AACD;;AACF;AACE;AA9CJ;;AAiDA,WAAOT,IAAI,CAACC,MAAD,CAAX;AACD,GArDD;AAsDD,CAzDD;;AA2DA,eAAeL,sBAAf","sourcesContent":["import socketIOClient from 'socket.io-client';\nimport {\n  SOCKET_TRIGGER_CONNECT, SOCKET_TRIGGER_DISCONNECT, SOCKET_EMIT\n} from '../actions/actionTypes';\nimport {\n  setSocketLoading, handleSocketConnect, setSocketError\n} from '../actions/socketActions';\n\nconst createSocketMiddleware = (url) => {\n  let socket;\n\n  return storeAPI => next => action => {\n    const dispatch = storeAPI.dispatch;\n\n    switch(action.type) {\n      case SOCKET_TRIGGER_CONNECT:\n        setSocketLoading(dispatch, true);\n\n        socket = socketIOClient(url);\n\n        socket.on('connect', (data) => {\n          handleSocketConnect(dispatch, data);\n        });\n\n        socket.on('connect_error', (error) => {\n          setSocketError(dispatch, error);\n        });\n\n        socket.on('error', (error) => {\n          setSocketError(dispatch, error);\n        });\n\n        socket.on('connect_timeout', (timeout) => {\n          setSocketError(dispatch, timeout);\n        });\n\n        socket.on('disconnect', (reason) => {\n          // reason is a String\n          // ‘io server disconnect’, ‘io client disconnect’, or ‘ping timeout’\n          setSocketError(dispatch, { message: reason });\n        });\n\n        socket.on('updateGameSession', (data) => {\n          setGameSessionState(dispatch, data);\n        });\n        break;\n      case SOCKET_TRIGGER_DISCONNECT:\n        if (socket) { socket.disconnect(); }\n        return;\n      case SOCKET_EMIT:\n        const { eventName } = action.payload;\n        const data = action.payload.data || {};\n\n        if (socket && socket.connected) {\n          socket.emit(eventName, data);\n        } else {\n          setSocketError(dispatch, { message: 'Socket is not connected' });\n        }\n        return;\n      default:\n        break;\n    }\n\n    return next(action);\n  }\n}\n\nexport default createSocketMiddleware;\n"]},"metadata":{},"sourceType":"module"}